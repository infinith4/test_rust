fn main() {
    {                      // sは、ここでは有効ではない。まだ宣言されていない
        let s = "hello";   // sは、ここから有効になる

        // sで作業をする
    }                      // このスコープは終わり。もうsは有効ではない
    //別の原因は、コードを書く際に、全ての文字列値が判明するわけではないからです: 
    //例えば、ユーザ入力を受け付け、それを保持したいとしたらどうでしょうか？
    //このような場面用に、Rustには、 2種類目の文字列型、String型があります。
    //この型はヒープにメモリを確保するので、 コンパイル時にはサイズが不明なテキストも保持することが
    //できるのです。from関数を使用して、 文字列リテラルからString型を生成できます。
    let mut s1 = String::from("hello");

    s1.push_str(", world!"); // push_str()関数は、リテラルをStringに付け加える
    
    println!("{}", s1); // これは`hello, world!`と出力する
    //コンパイル時にサイズが不明だったり、 
    //プログラム実行に合わせてサイズが可変なテキスト片用に一塊のメモリをバイナリに
    //確保しておくことは不可能です。

    let s2 = s1;
    //s1をs2に代入すると、String型のデータがコピーされます。つまり、スタックにあるポインタ、長さ、 許容量をコピーするということです。ポインタが指すヒープ上のデータはコピーしません。
    //println!("{}", s1);
                 //^^ value borrowed here after move
    println!("{}", s2);

    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);

    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
    //xは有効で、yにムーブされませんでした。
    //その理由は、整数のようなコンパイル時に既知のサイズを持つ型は、
    //スタック上にすっぽり保持されるので、 実際の値をコピーするのも高速だからです。
    //これは、変数yを生成した後にもxを無効化したくなる理由がないことを意味します。 

    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    // '{}'の長さは、{}です
    println!("The length of '{}' is {}.", s1, len);

    let mut s = String::from("hello");

    //可変な参照には大きな制約が一つあります: 特定のスコープで、ある特定のデータに対しては、 一つしか可変な参照を持てないことです。
    change(&mut s);  //&mut sで可変な参照を生成
    println!("changed : {}", s);
}

//アンド記号が参照であり、これのおかげで所有権をもらうことなく値を参照することができる
//&による参照の逆は、参照外しであり、参照外し演算子の*で達成できます。 
//関数の引数に参照を取ることを借用と呼びます
fn calculate_length(s: &String) -> usize {
    //s.push_str(", world");  //借用した何かを変更しようとしたら、エラー
    s.len()
}//// ここで、sはスコープ外になる。けど、参照しているものの所有権を持っているわけではないので
  // 何も起こらない

fn change(some_string: &mut String) {  //some_string: &mut Stringで可変な参照を受け入れなければなりません
    some_string.push_str(", world");
}